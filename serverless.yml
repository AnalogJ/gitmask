# Welcome to Serverless!
#
# This file is the main config file for your service.
# It's very minimal at this point and uses default values.
# You can always add more config options for more control.
# We've included some commented out config examples here.
# Just uncomment any of them to get that config option.
#
# For full config options, check the docs:
#    v1.docs.serverless.com
#
# Happy Coding!

service: gitmask-api # NOTE: update this with your service name

provider:
  cfLogs: true
  name: aws
  stage: 'beta'
  region: us-east-1
  timeout: 40 # optional, default is 6
  runtime: nodejs4.3
  environment:
    DOMAIN: git.gitmask.com
    DEPLOY_SHA: ${env:CIRCLE_SHA1}
    STAGE: ${opt:stage, self:provider.stage}
    NODE_ENV: production
    GITHUB_API_TOKEN: ${env:GITHUB_API_TOKEN}

custom:

  # overridden from https://github.com/serverless/serverless/blob/03cc50b246c656183110669126a632735ea46b15/lib/plugins/aws/deploy/compile/events/apiGateway/lib/method/integration.js#L106-L140
  standardRequestTemplate: >-
    #define( $loop )
      {
      #foreach($key in $map.keySet())
          #set( $k = $util.escapeJavaScript($key) )
          #set( $v = $util.escapeJavaScript($map.get($key)).replaceAll("\\\\'", "'") )
          "$k":
            "$v"
            #if( $foreach.hasNext ) , #end
      #end
      }
    #end
    {
      "body": $input.json("$"),
      "method": "$context.httpMethod",
      "principalId": "$context.authorizer.principalId",
      "stage": "$context.stage",
      #set( $map = $input.params().header )
      "headers": $loop,
      #set( $map = $input.params().querystring )
      "query": $loop,
      #set( $map = $input.params().path )
      "path": $loop,
      #set( $map = $context.identity )
      "identity": $loop,
      #set( $map = $stageVariables )
      "stageVariables": $loop,

      "httpMethod": "$context.httpMethod",

      #set( $tokenVal = $input.params().header.get('Authorization').split(' ') )
      #if( $tokenVal.size() == 2 )
        "token": "$tokenVal[1]"
      #else
      "token": ""
      #end
    }
  standardResponseTemplate: "{\"success\":true, \"data\": $input.json('$') }"
  errorResponseTemplate: "#set($inputRoot = $input.path('$.errorMessage')){\"success\":false, \"error\": $inputRoot }"

  standardRequests:
    template:
      application/json: ${self:custom.standardRequestTemplate}

  standardResponses:
    headers:
      Content-Type: "'application/json'"
    template: ${self:custom.standardResponseTemplate}
    statusCodes:
      200:
        pattern: ''
        template:
          application/json: ${self:custom.standardResponseTemplate}
      400:
        template:
          application/json: ${self:custom.errorResponseTemplate}
        pattern: '.*\[400\].*'
      404:
        template:
          application/json: ${self:custom.errorResponseTemplate}
        pattern: '.*\[404\].*'
      500:
        template:
          application/json: ${self:custom.errorResponseTemplate}
        pattern: '.*\[500\].*'


# you can add packaging information here
package:
#  individually: true # required for https://github.com/FidelLimited/serverless-plugin-optimize
  # only the following paths will be included in the resulting artifact which will be uploaded. Without specific include everything in the current folder will be included
  include:
    - src
    - functions
    - opt
  # The following paths will be excluded from the resulting artifact. If both include and exclude are defined we first apply the include, then the exclude so files are guaranteed to be excluded
  exclude:
    - tmp
    - .git
    - .idea
    - no

functions:
# UNAUTHENTICATED METHODS
# TODO: we should re-enable this endpoint once serverless figures out how to get around 200 CF limit.
  version:
    handler: src/version.handler
    events:
      - http:
          path: version
          method: get
          response: ${self:custom.standardResponses}
          integration: lambda

  patch:
    handler: src/patch.handler
    timeout: 120
    memorySize: 128
    events:
      - http:
          path: patch/{scm}/{org}/{repo}
          method: post
          response: ${self:custom.standardResponses}
          integration: lambda

plugins:
   - serverless-prune-plugin